window.addEventListener("load", function() {
    function J(a, c) {
        for (var d in c)
            if (c.hasOwnProperty(d))
                if ("object" == typeof a[d])
                    J(a[d], c[d]);
                else
                    a[d] = c[d];
        return a
    }
    function E(a) {
        if ("undefined" != typeof a.offsetX)
            return {
                x: a.offsetX,
                y: a.offsetY
            };
        else {
            var c = a.target.ownerSVGElement
              , d = c.getScreenCTM();
            c = c.createSVGPoint();
            c.x = a.clientX;
            c.y = a.clientY;
            return c.matrixTransform(d.inverse())
        }
    }
    function K(a, c) {
        for (var d in c)
            c.hasOwnProperty(d) && a.setAttribute(d, String(c[d]));
        return a
    }
    function F(a, c) {
        return K(document.createElementNS("http://www.w3.org/2000/svg", a), c)
    }
    function M(a) {
        if (a < 0)
            return 2 * Math.PI + a % (2 * Math.PI);
        if (a < 2 * Math.PI)
            return a;
        return a % (2 * Math.PI)
    }
    function P(a, c, d, j, m, s, k, l) {
        var n, t;
        if (a < d) {
            n = a;
            t = d
        } else {
            n = d;
            t = a
        }
        if (t < void 0 || void 0 < n)
            return null;
        if (c < j) {
            n = c;
            t = j
        } else {
            n = j;
            t = c
        }
        if (t < void 0 || void 0 < n)
            return null;
        var h = a - d;
        n = c - j;
        var q = m - k;
        t = s - l;
        var b = h * t - n * q;
        if (b === 0)
            return null;
        var f = a * j - c * d
          , i = m * l - s * k;
        h = (f * q - h * i) / b;
        if (h + 0.0010 < Math.max(Math.min(a, d), Math.min(m, k)) || h - 0.0010 > Math.min(Math.max(a, d), Math.max(m, k)))
            return null;
        a = (f * t - n * i) / b;
        if (a + 0.0010 < Math.max(Math.min(c, j), Math.min(s, l)) || a - 0.0010 > Math.min(Math.max(c, j), Math.max(s, l)))
            return null;
        return {
            x: h,
            y: a
        }
    }
    function u(a) {
        return document.getElementById(a)
    }
    function v(a, c, d) {
        a.addEventListener(c, d, false)
    }
    function D() {
        for (var a = ["setup", "config", "inverse"], c = a.length; --c >= 0; ) {
            var d = a[c];
            if (u("robotMode-" + d).checked)
                return d
        }
        return a[0]
    }
    function N(a, c, d) {
        this.length = a;
        this.angle = c;
        this.name = d;
        var j = this;
        v(u(d + "end"), "mousedown", function() {
            A.mode = D();
            if (A.mode != "inverse")
                A.startDrag(function(m, s) {
                    var k = j.getPosition()
                      , l = k.x + m;
                    k = k.y + s;
                    A.mode == "setup" && j.setLength(Math.sqrt(l * l + k * k));
                    j.setAngle(Math.atan2(k, l) / B)
                }, j.getParentTransform(), A.mode == "setup" ? G.update : null)
        })
    }
    function Q() {
        this.y = this.x = 200;
        this.name = "robot";
        u(this.name);
        for (var a = this, c = 1; c <= 2; ++c)
            v(u(this.name + "Base" + c), "mousedown", function() {
                A.mode = D();
                A.mode == "setup" && A.startDrag(function(d, j) {
                    a.setPosition(a.x + d, a.y + j)
                }, a.getParentTransform(), G.update)
            });
        c = new N(75,45,"arm1");
        this.attach(c);
        c.attach(new N(50,90,"arm2"))
    }
    var p = 400
      , B = Math.PI / 180
      , x = J(function(a, c, d, j, m, s) {
        this.a = a;
        this.b = c;
        this.c = d;
        this.d = j;
        this.e = m;
        this.f = s
    }, {
        prototype: {
            multiply: function(a) {
                return new x(this.a * a.a + this.c * a.b,this.b * a.a + this.d * a.b,this.a * a.c + this.c * a.d,this.b * a.c + this.d * a.d,this.a * a.e + this.c * a.f + this.e,this.b * a.e + this.d * a.f + this.f)
            },
            transform: function(a) {
                return {
                    x: this.a * a.x + this.c * a.y + this.e,
                    y: this.b * a.x + this.d * a.y + this.f
                }
            },
            invert: function() {
                var a = 1 / (this.a * this.d - this.c * this.b);
                return new x(this.d * a,-this.b * a,-this.c * a,this.a * a,(this.c * this.f - this.e * this.d) * a,(this.e * this.b - this.a * this.f) * a)
            },
            toString: function() {
                return "[ " + this.a + " " + this.c + " " + this.e + " / " + this.b + " " + this.d + " " + this.f + " / 0 0 1 ]"
            }
        },
        translate: function(a, c) {
            return new x(1,0,0,1,a,c)
        },
        scale: function(a, c) {
            return new x(a,0,0,c,0,0)
        },
        rotate: function(a) {
            a *= B;
            var c = Math.sin(a);
            a = Math.cos(a);
            return new x(a,c,-c,a,0,0)
        }
    });
    x.IDENTITY = new x(1,0,0,1,0,0);
    var A = function() {
        var a = null, c = null, d = null, j;
        v(window, "mousedown", function(m) {
            if (c)
                j = a.transform(E(m))
        });
        v(window, "mousemove", function(m) {
            if (c) {
                m = a.transform(E(m));
                c(m.x - j.x, m.y - j.y);
                j = m
            }
        });
        v(window, "mouseup", function() {
            if (c) {
                c = null;
                d && d()
            }
        });
        return {
            mode: null,
            startDrag: function(m, s, k) {
                s = s.invert();
                c = m;
                a = s;
                d = k
            },
            isDragging: function() {
                return !!c
            }
        }
    }();
    u("robotMode-setup").checked = true;
    A.mode = D();
    var R = J(function() {}, {
        prototype: {
            attach: function(a) {
                this.next = a;
                a.prev = this
            },
            getLocalTransform: function() {
                return x.IDENTITY
            },
            getTransform: function() {
                var a = this.getLocalTransform();
                return this.prev ? this.prev.getTransform().multiply(a) : a
            },
            getParentTransform: function() {
                return this.prev ? this.prev.getTransform() : x.IDENTITY
            }
        }
    });
    N.prototype = J(new R, {
        getLocalTransform: function() {
            return x.translate(this.length, 0).multiply(x.rotate(this.angle))
        },
        getPosition: function() {
            var a = this.angle * B;
            return {
                x: Math.cos(a) * this.length,
                y: Math.sin(a) * this.length
            }
        },
        setPosition: function(a, c) {
            this.setLength(Math.sqrt(a * a + c * c));
            this.setAngle(Math.atan2(c, a) / B)
        },
        setLength: function(a) {
            this.length = a;
            u(this.name + "scale").setAttribute("transform", "scale(" + a + " 1)");
            u(this.name + "trans").setAttribute("transform", "translate(" + a + ")")
        },
        setAngle: function(a) {
            this.angle = a;
            u(this.name + "rot").setAttribute("transform", "rotate(" + a + ")");
            G.moveX();
            S.updateLaser()
        }
    });
    Q.prototype = J(new R, {
        setPosition: function(a, c) {
            this.x = a;
            this.y = c;
            u(this.name).setAttribute("transform", "translate(" + a + " " + c + ")")
        },
        getLocalTransform: function() {
            return x.translate(this.x, this.y)
        }
    });
    var o = new Q
      , z = []
      , S = function() {
        function a(b, f) {
            this.parent = b;
            this.color = f;
            this.rgb = "rgb(" + f + ")";
            this.points = [];
            this.bounds = {
                x1: Infinity,
                y1: Infinity,
                x2: -Infinity,
                y2: -Infinity
            }
        }
        function c(b, f, i, e) {
            for (var g = 0; g < z.length; ++g)
                if (z[g].intersectsSegment(b, f, i, e))
                    return true;
            return false
        }
        function d(b, f) {
            var i = o.x
              , e = o.y
              , g = i + Math.cos(b) * o.next.length
              , r = e + Math.sin(b) * o.next.length;
            if (c(i, e, g, r))
                return false;
            return !c(g, r, g + Math.cos(b + f) * o.next.next.length, r + Math.sin(b + f) * o.next.next.length)
        }
        function j() {
            var b = u("myGradient").getElementsByTagName("stop")
              , f = d(o.next.angle * B, o.next.next.angle * B) ? "#0f0" : "#f00";
            [0, 1, 4, 5].forEach(function(i) {
                b[i].setAttribute("stop-color", f)
            })
        }
        function m(b) {
            if (b.target.checked && l) {
                l.remove();
                l = null;
                t.removeChild(h)
            }
        }
        function s(b) {
            function f(C) {
                return Math.atan2(e, i) - Math.atan2(r * Math.sin(C), g + r * Math.cos(C))
            }
            b = E(b);
            var i = b.x - o.x
              , e = b.y - o.y
              , g = o.next.length
              , r = o.next.next.length;
            b = (g * g + r * r - i * i - e * e) / (2 * g * r);
            var w;
            if (b < -1) {
                b = 0;
                w = Math.atan2(e, i)
            } else if (b > 1) {
                b = Math.PI;
                w = e * i ? Math.atan2(e, i) : 0
            } else {
                b = Math.PI - Math.acos(b);
                w = o.next.next.angle * B;
                if (Math.min(M(w - -b), M(-b - w)) < Math.min(M(w - b), M(b - w)))
                    b = -b;
                w = f(b);
                if (!d(w, b)) {
                    var L = f(-b);
                    if (d(L, -b)) {
                        b = -b;
                        w = L
                    }
                }
            }
            o.next.setAngle(w / B);
            o.next.next.setAngle(b / B)
        }
        a.prototype = {
            isClosing: function(b, f) {
                var i = this.points.length, e;
                if (e = i > 2) {
                    e = this.points[0][0] - b;
                    var g = this.points[0][1] - f;
                    if (!(e = e * e + g * g <= 16)) {
                        e = this.points[i - 1][0] - b;
                        i = this.points[i - 1][1] - f;
                        e = e * e + i * i <= 16
                    }
                    e = e
                }
                if (e)
                    return true;
                return false
            },
            add: function(b, f) {
                this.points.push([b, f]);
                this.bounds.x1 = Math.min(this.bounds.x1, b);
                this.bounds.y1 = Math.min(this.bounds.y1, f);
                this.bounds.x2 = Math.max(this.bounds.x2, b);
                this.bounds.y2 = Math.max(this.bounds.y2, f);
                switch (this.points.length) {
                case 1:
                    this.elem = this.parent.appendChild(F("circle", {
                        r: 1,
                        fill: this.rgb,
                        cx: b,
                        cy: f
                    }));
                    this.parent.ownerSVGElement.forceRedraw();
                    break;
                case 2:
                    this.parent.removeChild(this.elem);
                    this.elem = this.parent.appendChild(F("line", {
                        stroke: this.rgb,
                        "stroke-width": 1,
                        x1: this.points[0][0],
                        y1: this.points[0][1],
                        x2: this.points[1][0],
                        y2: this.points[1][1]
                    }));
                    this.parent.ownerSVGElement.forceRedraw();
                    break;
                case 3:
                    this.parent.removeChild(this.elem);
                    this.elem = this.parent.appendChild(F("polyline", {
                        fill: "none",
                        stroke: this.rgb,
                        points: this.points.join(" ")
                    }));
                    this.parent.ownerSVGElement.forceRedraw();
                    break;
                default:
                    K(this.elem, {
                        points: this.points.join(" ")
                    });
                    this.parent.ownerSVGElement.forceRedraw()
                }
            },
            close: function() {
                if (this.points.length > 2) {
                    this.parent.removeChild(this.elem);
                    this.elem = this.parent.appendChild(F("polygon", {
                        fill: this.rgb,
                        stroke: "black",
                        points: this.points.join(" ")
                    }));
                    var b = this;
                    v(this.elem, "mousedown", function() {
                        D() == "setup" && A.startDrag(function(f, i) {
                            b.bounds.x1 += f;
                            b.bounds.y1 += i;
                            b.bounds.x2 += f;
                            b.bounds.y2 += i;
                            for (var e = 0; e < b.points.length; ++e) {
                                b.points[e][0] += f;
                                b.points[e][1] += i
                            }
                            K(b.elem, {
                                points: b.points.join(" ")
                            })
                        }, x.IDENTITY, G.update)
                    })
                }
            },
            remove: function() {
                this.parent.removeChild(this.elem)
            },
            intersectsSegment: function(b, f, i, e) {
                var g = this.bounds;
                if (b < g.x1 && i < g.x1 || b > g.x2 && i > g.x2 || f < g.y1 && e < g.y1 || f > g.y2 && e > g.y2)
                    return false;
                g = this.points;
                var r = g.length - 1;
                if (P(b, f, i, e, g[0][0], g[0][1], g[r][0], g[r][1]))
                    return true;
                for (; --r >= 0; )
                    if (P(b, f, i, e, g[r][0], g[r][1], g[r + 1][0], g[r + 1][1]))
                        return true;
                return false
            }
        };
        var k = [[255, 0, 0], [255, 165, 0], [0, 128, 0], [0, 0, 255], [128, 0, 128], [128, 128, 128]]
          , l = null
          , n = u("robotPaint")
          , t = u("obstacles");
        j();
        v(u("removeAll"), "click", function() {
            for (var b = 0; b < z.length; ++b)
                z[b].remove();
            z.length = 0;
            G.update();
            u("removeAll").disabled = true;
            return false
        });
        v(u("robotMode-config"), "click", m);
        v(u("robotMode-inverse"), "click", m);
        var h = null
          , q = false;
        v(n, "mousedown", function(b) {
            if (D() == "inverse") {
                q = true;
                s(b)
            }
        });
        v(window, "mouseup", function() {
            q = false
        });
        v(n, "click", function(b) {
            if (l) {
                b = E(b);
                if (l.isClosing(b.x, b.y)) {
                    l.close();
                    z.push(l);
                    l = null;
                    G.update();
                    u("removeAll").disabled = false;
                    t.removeChild(h)
                } else {
                    l.add(b.x, b.y);
                    t.appendChild(h);
                    K(h, {
                        x1: b.x,
                        y1: b.y
                    })
                }
            }
        });
        v(n, "mousemove", function(b) {
            if (l) {
                var f = E(b);
                K(h, {
                    x2: String(f.x),
                    y2: String(f.y)
                })
            }
            D() == "inverse" && q && s(b)
        });
        v(u("robotBG"), "click", function(b) {
            if (!A.isDragging() && D() == "setup") {
                b = E(b);
                if (!l) {
                    l = new a(t,k[z.length % k.length]);
                    h = F("line", {
                        stroke: "black",
                        "stroke-width": 1,
                        "stroke-dasharray": "4,2",
                        "stroke-dashoffset": 2,
                        x1: b.x,
                        y1: b.y,
                        x2: b.x,
                        y2: b.y
                    });
                    b = F("animate", {
                        attributeName: "stroke-dashoffset",
                        attributeType: "XML",
                        from: "0",
                        to: "6",
                        dur: "6s",
                        repeatCount: "indefinite"
                    });
                    h.appendChild(b);
                    t.appendChild(h)
                }
            }
        });
        return {
            isValidConfiguration: d,
            updateLaser: j
        }
    }()
      , G = function() {
        function a(h) {
            var q;
            q = h.clientX + (0 | document.documentElement.scrollLeft) + (0 | document.body.scrollLeft);
            var b = h.clientY + (0 | document.documentElement.scrollTop) + (0 | document.body.scrollTop);
            h = h.target;
            do {
                q -= h.offsetLeft;
                b -= h.offsetTop
            } while (h = h.offsetParent);q = {
                x: q,
                y: b
            };
            o.next.setAngle(q.x * 360 / p);
            o.next.next.setAngle(q.y * 360 / p)
        }
        function c() {
            l = k.createImageData(p, p);
            n = l.data
        }
        function d() {
            function h() {
                k.fillText("Updating C-Space...", (p - k.measureText("Updating C-Space...").width) / 2, (p - 10) / 2)
            }
            function q() {
                m >= z.length && k.putImageData(l, 0, 0);
                b(z[m]);
                k.putImageData(l, 0, 0);
                j();
                if (++m < z.length) {
                    h();
                    setTimeout(q, 1)
                }
            }
            function b(f) {
                function i() {
                    if (n[y + 3]) {
                        n[y] = g + n[y] >> 1;
                        n[y + 1] = r + n[y + 1] >> 1;
                        n[y + 2] = w + n[y + 2] >> 1
                    } else {
                        n[y] = g;
                        n[y + 1] = r;
                        n[y + 2] = w;
                        n[y + 3] = 255
                    }
                }
                var e = f.color
                  , g = e[0]
                  , r = e[1]
                  , w = e[2];
                e = o.x;
                for (var L = o.y, C = 0; C < p; ++C) {
                    var H = C * Math.PI * 2 / p
                      , O = e + Math.cos(H) * o.next.length;
                    H = L + Math.sin(H) * o.next.length;
                    var y = C * 4;
                    if (f.intersectsSegment(e, L, O, H))
                        for (var I = 0; I < p; ++I) {
                            i();
                            y += p * 4
                        }
                    else {
                        var T = o.next.next.length;
                        for (I = 0; I < p; ++I) {
                            var U = (C + I) * Math.PI * 2 / p;
                            f.intersectsSegment(O, H, O + Math.cos(U) * T, H + Math.sin(U) * T) && i();
                            y += p * 4
                        }
                    }
                }
            }
            k.clearRect(0, 0, p, p);
            if (z.length === 0)
                j();
            else {
                c();
                h();
                m = 0;
                setTimeout(q, 1)
            }
        }
        function j() {
            var h = o.next.angle * p / 360
              , q = o.next.next.angle * p / 360;
            h += p * (1 + -h / p | 0);
            q += p * (1 + -q / p | 0);
            k.fillRect(h - 3, q, 7, 1);
            k.fillRect(h, q - 3, 1, 7)
        }
        var m = -1, s = u("canvas"), k = s.getContext("2d"), l, n, t = false;
        v(s, "mousedown", function(h) {
            a(h);
            t = true
        });
        v(s, "mousemove", function(h) {
            t && a(h)
        });
        v(window, "mouseup", function() {
            t = false
        });
        c();
        return {
            update: function() {
                d();
                S.updateLaser()
            },
            moveX: function() {
                z.length ? k.putImageData(l, 0, 0) : k.clearRect(0, 0, p, p);
                j()
            }
        }
    }()
}, false);
